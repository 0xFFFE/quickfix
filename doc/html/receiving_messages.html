<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html>
<head>
  <link href="doxygen.css" rel="stylesheet" type="text/css">

  <title>Receiving Messages</title>
</head>

<body>
  <div class='header'>
    <div class='headerTitle'>
      Receiving Messages
    </div>
  </div>

  <div class='contents'>
    <p>Most of the messages you will be interested in looking at
    will be arriving in your overloaded <b>fromApp</b> function of
    your application. You can get fields out of messages with
    different degrees of type safety. The type in question here is
    the FIX message type. When the application passes you a
    <b>Message</b> class, the C++ type checker has no idea what
    specific FIX message it is, you must determine that
    dynamically. There is, however, a way we can make C++ aware of
    this type information. First we will cover how to dynamically
    retreive fields from a message, then we will show you the
    prefered type safe way. Keep in mind that all messages have a
    header and a trailer. If you want to see fields in them, you
    must first call <b>getHeader()</b> or <b>getTrailer()</b> to
    get access to them. Otherwise you use them just like the
    message.</p>

    <h2>Least Type Safe</h2>

    <p>This method of retreiving data from messages is <b>strongly
    discouraged</b> and is generally only useful for writing more
    low level interfaces for other languages and
    middleware.</p>Here is a sample code segment for this type of
    retrieval: See this code in <a href=
    "python/receiving_messages_1.html">PYTHON</a>, <a href=
    "ruby/receiving_messages_1.html">RUBY</a>
    <pre class='fragment'>
void fromApp( const FIX::Message&amp; message, const FIX::SessionID&amp; sessionID )
  throw( FIX::FieldNotFound&amp;, FIX::IncorrectDataFormat&amp;, FIX::IncorrectTagValue&amp;, FIX::UnsupportedMessageType&amp; )
{
  // retreive value into string with integer field ID
  std::string value;
  value = message.getField(44);

  // retrieve value into a field base with integer field ID
  FIX::FieldBase field(44, "");
  message.getField(field);

  // retreive value with an enumeration, a little better
  message.getField(FIX::FIELD::Price);
}
</pre>

    <h2>More Type Safe</h2>

    <p>A way to add some type safety to this is by using field
    classes that represent all the FIX defined fields. This is
    sometimes useful in an application, but is generally only used
    within code segments that need to be version independent
    (meaning versions of FIX). For example, our Session class is
    implemented using mostly these. It is generally not recomended
    for most applications. This will also get fields as their
    appropriate type, not just as strings.</p>See this code in
    <a href="python/receiving_messages_2.html">PYTHON</a>, <a href=
    "ruby/receiving_messages_2.html">RUBY</a>
    <pre class='fragment'>
void fromApp( const FIX::Message&amp; message, const FIX::SessionID&amp; sessionID )
  throw( FIX::FieldNotFound&amp;, FIX::IncorrectDataFormat&amp;, FIX::IncorrectTagValue&amp;, FIX::UnsupportedMessageType&amp; )
{
  // retrieve value into field class
  FIX::Price price;
  message.getField(price);

  // another field...
  FIX::ClOrdID clOrdID;
  message.getField(clOrdID);
}
</pre>

    <h2>Most Type Safe... DO THIS!</h2>

    <p>Here is the most type safe and <b>highly encouraged</b>
    method for retreiving data from a message. QuickFIX has message
    classes that correlate to all the messages defined in the spec.
    They are, just like the field classes, generated directly off
    of the FIX specifications. To take advantage of this, you must
    break the messages out with the supplied <b>MessageCracker</b>.
    Also notice we are no longer using a generic <b>Message</b>
    class and we are now using <b>get</b> instead of
    <b>getField</b>. Keep in mind you can still use <b>getField</b>
    as all of these classes derive from <b>Message</b></p>See this
    code in PYTHON(not supported), RUBY(not supported)
    <pre class='fragment'>
void fromApp( const FIX::Message&amp; message, const FIX::SessionID&amp; sessionID )
  throw( FIX::FieldNotFound&amp;, FIX::IncorrectDataFormat&amp;, FIX::IncorrectTagValue&amp;, FIX::UnsupportedMessageType&amp; )
{
  crack(message, sessionID);
}

void onMessage( const FIX42::NewOrderSingle&amp; message, const FIX::SessionID&amp; )
{
  FIX::ClOrdID clOrdID;
  message.get(clOrdID);

  FIX::ClearingAccount clearingAccount;
  message.get(clearingAccount);
}

void onMessage( const FIX41::NewOrderSingle&amp; message, const FIX::SessionID&amp; )
{
  FIX::ClOrdID clOrdID;
  message.get(clOrdID);

  // compile time error!! field not defined in FIX41
  FIX::ClearingAccount clearingAccount;
  message.get(clearingAccount);
}

void onMessage( const FIX42::OrderCancelRequest&amp; message, const FIX::SessionID&amp; )
{
  FIX::ClOrdID clOrdID;
  message.get(clOrdID);

  // compile time error!! field not defined for OrderCancelRequest
  FIX::Price price;
  message.get(price);
}
</pre>

    <p>In order to use this you must use the <b>MessageCracker</b>
    as a mixin to your application. This will provide you with the
    <b>crack</b> function and allow you to overload specific
    message functions. Any function you do not overload will by
    default throw an <b>UnsupportedMessageType</b> exception<br>
    <br>
    Define your application like this:</p>See this code in
    PYTHON(not supported), RUBY(not supported)
    <pre class='fragment'>
#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"

class MyApplication
: public FIX::Application,
  public FIX::MessageCracker
</pre>
  </div>
</body>
</html>
